<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR NFT — Video Fix</title>

  <!-- A-Frame + AR.js -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.6.0/dist/aframe-master.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    body { margin:0; font-family:system-ui, Roboto, "Segoe UI", sans-serif; overflow:hidden; }
    #ui { position:absolute; left:12px; top:12px; z-index:9999; background:rgba(0,0,0,0.55); color:#fff; padding:10px; border-radius:8px;}
    #tap { display:none; margin-top:8px; padding:8px 10px; border-radius:6px; border:none; cursor:pointer;}
    #log { margin-top:8px; font-size:0.85rem; color:#ffd; white-space:pre-wrap; max-width:340px; max-height:220px; overflow:auto; }
    .loader { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.85); color:#fff; z-index:9998; font-size:1.1rem; }
  </style>
</head>
<body>
  <div class="loader" id="loader">Loading — if stuck, tap "Tap to start"</div>

  <div id="ui">
    <div id="status">Init</div>
    <button id="debugBtn">Debug: show plane in front of camera</button>
    <button id="tap">Tap to start video</button>
    <div id="log"></div>
  </div>

  <!-- KEEP video renderable (tiny + near-transparent). DO NOT use display:none -->
  <video id="vid"
         src="./mov_bbb.mp4"
         preload="auto"
         loop
         muted
         playsinline
         webkit-playsinline
         crossorigin="anonymous"
         style="position:absolute;left:0;top:0;width:2px;height:2px;opacity:0.001;">
  </video>

  <a-scene vr-mode-ui="enabled:false" embedded renderer="logarithmicDepthBuffer:true"
           arjs="trackingMethod:best; sourceType:webcam; debugUIEnabled:false;">
    <!-- local NFT folder next to index.html -->
    <a-nft id="pinball" type="nft" url="./pinball" smooth="true" smoothCount="20" smoothTolerance="0.01" smoothThreshold="5">
      <!-- plane uses video as material; rotation -90 0 0 typically aligns to printed target -->
      <a-plane id="video-plane" rotation="-90 0 0" position="0 0 0" width="1.6" height="0.9"
               visible="false" material="shader: flat; src: #vid; side: double;"></a-plane>
    </a-nft>

    <a-entity camera id="camera"></a-entity>
  </a-scene>

  <script>
  (function(){
    const status = s => document.getElementById('status').textContent = s;
    const logEl = document.getElementById('log');
    const loader = document.getElementById('loader');
    const tapBtn = document.getElementById('tap');
    const debugBtn = document.getElementById('debugBtn');

    function dbg(...a){ console.log('[AR]', ...a); logEl.textContent = (new Date().toLocaleTimeString()+' — '+a.join(' ')) + '\n' + logEl.textContent; }

    const video = document.getElementById('vid');
    const marker = document.getElementById('pinball');
    const plane = document.getElementById('video-plane');

    // ensure video ready for texture
    video.crossOrigin = 'anonymous';
    video.muted = true;
    try { video.load(); } catch(e){ dbg('video.load() error', e); }

    // update three texture each frame
    AFRAME.registerComponent('video-texture-updater', {
      tick: function(){
        const mesh = this.el.getObject3D('mesh');
        if (!mesh) return;
        const mat = mesh.material;
        if (Array.isArray(mat)) {
          mat.forEach(m => { if (m && m.map && m.map.image === video) m.map.needsUpdate = true; });
        } else {
          if (mat && mat.map && mat.map.image === video) mat.map.needsUpdate = true;
        }
      }
    });
    plane.setAttribute('video-texture-updater','');

    // auto-size plane when metadata available
    video.addEventListener('loadedmetadata', () => {
      dbg('loadedmetadata', video.videoWidth, video.videoHeight);
      if (video.videoWidth && video.videoHeight) {
        const aspect = video.videoWidth / video.videoHeight;
        const width = 1.0; // tune to match printed target
        const height = width / aspect;
        plane.setAttribute('width', width);
        plane.setAttribute('height', height);
        dbg('plane sized', width, height, 'aspect', aspect.toFixed(2));
      }
    });

    // hide loader when a frame is ready
    video.addEventListener('canplay', () => {
      dbg('canplay fired');
      setTimeout(()=>{ loader.style.display='none'; }, 200);
    });

    // try play helper
    async function tryPlay(){
      try {
        const p = video.play();
        if (p !== undefined) await p;
        dbg('video.play() resolved - playing');
        return true;
      } catch (err) {
        dbg('video.play() rejected', err);
        return false;
      }
    }

    // marker events
    marker.addEventListener('markerFound', async () => {
      dbg('markerFound');
      plane.setAttribute('visible','true');
      // ensure material points to video (rebind)
      plane.setAttribute('material','shader: flat; src: #vid; side: double;');
      const ok = await tryPlay();
      if (!ok) {
        status('Autoplay blocked — tap to start');
        tapBtn.style.display = 'inline-block';
      } else {
        status('Playing on marker');
        tapBtn.style.display = 'none';
      }
    });

    marker.addEventListener('markerLost', () => {
      dbg('markerLost');
      plane.setAttribute('visible','false');
      try { video.pause(); video.currentTime = 0; } catch(e) {}
      status('Marker lost');
    });

    // Tap fallback
    tapBtn.addEventListener('click', async () => {
      const ok = await tryPlay();
      if (ok) { tapBtn.style.display='none'; status('Playing'); }
    });
    document.body.addEventListener('click', () => {/* single click helps some browsers */}, { once:true });

    // debug button: show plane in front of camera for testing
    debugBtn.addEventListener('click', () => {
      dbg('Debug: placing plane in front of camera for 6s');
      const cam = document.getElementById('camera');
      const dbgPlane = document.createElement('a-plane');
      dbgPlane.setAttribute('position','0 0 -1.2');
      dbgPlane.setAttribute('rotation','0 0 0');
      dbgPlane.setAttribute('width', plane.getAttribute('width') || 1.0);
      dbgPlane.setAttribute('height', plane.getAttribute('height') || 0.56);
      dbgPlane.setAttribute('material','shader: flat; src: #vid; side: double;');
      cam.appendChild(dbgPlane);
      tryPlay();
      setTimeout(()=>{ if (dbgPlane.parentNode) dbgPlane.parentNode.removeChild(dbgPlane); dbg('debug plane removed'); }, 6000);
    });

    // final ready
    status('Ready — point camera at printed pinball image');
    dbg('Initialized. Video src=' + video.src);
  })();
  </script>
</body>
</html>
