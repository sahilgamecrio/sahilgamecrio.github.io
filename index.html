<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>AR — Precise Video Over Image (calibrate)</title>

  <script src="https://cdn.jsdelivr.net/npm/aframe@1.6.0/dist/aframe-master.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    body{margin:0; font-family:system-ui, Roboto; overflow:hidden;}
    #panel{position:absolute; left:10px; top:10px; z-index:9999; background:rgba(0,0,0,0.6); color:#fff; padding:10px; border-radius:8px;}
    #panel input{width:80px}
    #panel button{margin-left:6px}
    #msg{margin-top:8px; font-size:0.9rem; color:#ffd;}
  </style>
</head>
<body>
  <div id="panel">
    Printed width (cm): <input id="printWidth" type="number" step="0.1" value="20"> 
    <button id="applyBtn">Apply</button><br>
    <button id="nudgeLeft">◀︎</button>
    <button id="nudgeRight">▶︎</button>
    <button id="nudgeUp">▲</button>
    <button id="nudgeDown">▼</button>
    <div id="msg">Set printed width and point camera at target.</div>
  </div>

  <!-- video must be renderable (tiny & almost transparent) -->
  <video id="vid" src="./mov_bbb.mp4" preload="auto" loop muted playsinline webkit-playsinline crossorigin="anonymous"
         style="position:absolute; left:0; top:0; width:2px; height:2px; opacity:0.001;"></video>

  <a-scene vr-mode-ui="enabled:false" embedded
           arjs="trackingMethod:best; sourceType:webcam; debugUIEnabled:false;">
    <a-nft id="marker" type="nft" url="./pinball" smooth="true" smoothCount="40" smoothTolerance="0.01" smoothThreshold="2">
      <a-plane id="videoPlane" rotation="-90 0 0" position="0 0 0" material="shader: flat; src: #vid; side: double;" visible="false"></a-plane>
    </a-nft>
    <a-entity camera></a-entity>
  </a-scene>

  <script>
  (function(){
    const vid = document.getElementById('vid');
    const plane = document.getElementById('videoPlane');
    const marker = document.getElementById('marker');
    const msg = document.getElementById('msg');
    const printWidthInput = document.getElementById('printWidth');
    const applyBtn = document.getElementById('applyBtn');
    const nudges = {
      left: document.getElementById('nudgeLeft'),
      right: document.getElementById('nudgeRight'),
      up: document.getElementById('nudgeUp'),
      down: document.getElementById('nudgeDown')
    };

    // force video texture updates each frame
    AFRAME.registerComponent('video-texture-updater', {
      tick: function(){
        const mesh = this.el.getObject3D('mesh');
        if (!mesh) return;
        const mat = mesh.material;
        if (Array.isArray(mat)) {
          mat.forEach(m => { if (m && m.map && m.map.image === vid) m.map.needsUpdate = true; });
        } else {
          if (mat && mat.map && mat.map.image === vid) mat.map.needsUpdate = true;
        }
      }
    });
    plane.setAttribute('video-texture-updater','');

    // auto-size plane when metadata arrives
    vid.addEventListener('loadedmetadata', () => {
      if (!vid.videoWidth || !vid.videoHeight) return;
      plane.dataset.videoAspect = vid.videoWidth / vid.videoHeight;
      msg.textContent = 'Video metadata loaded. Aspect: ' + plane.dataset.videoAspect.toFixed(3);
      // keep plane hidden until marked found
    });

    // play/pause on marker events
    marker.addEventListener('markerFound', async () => {
      plane.setAttribute('visible','true');
      // rebind material just in case
      plane.setAttribute('material','shader: flat; src: #vid; side: double;');
      try { await vid.play(); msg.textContent = 'Playing'; } catch(e) { msg.textContent = 'Autoplay blocked — tap screen'; }
    });
    marker.addEventListener('markerLost', () => {
      plane.setAttribute('visible','false');
      try { vid.pause(); vid.currentTime = 0; } catch(e) {}
      msg.textContent = 'Marker lost';
    });

    // helper: set plane size by printed width (cm -> meters)
    function applyPrintedWidthCm(cm) {
      const meters = parseFloat(cm) / 100;
      const aspect = parseFloat(plane.dataset.videoAspect) || 16/9;
      const height = meters / aspect;
      plane.setAttribute('width', meters);
      plane.setAttribute('height', height);
      msg.textContent = `Plane set: ${meters.toFixed(3)} m × ${height.toFixed(3)} m (aspect ${aspect.toFixed(3)})`;
    }

    // apply button
    applyBtn.addEventListener('click', () => {
      const cm = parseFloat(printWidthInput.value);
      if (!cm || cm <= 0) { msg.textContent = 'Enter a valid printed width in cm'; return; }
      applyPrintedWidthCm(cm);
    });

    // nudge controls: small local adjustments (in meters)
    function nudge(dx, dy) {
      const p = plane.getAttribute('position');
      const nx = (p.x || 0) + (dx || 0);
      const ny = (p.y || 0) + (dy || 0);
      plane.setAttribute('position', `${nx} ${ny} ${p.z || 0}`);
      msg.textContent = `Nudged to ${nx.toFixed(3)}, ${ny.toFixed(3)}`;
    }
    nudges.left.addEventListener('click', () => nudge(-0.005,0));
    nudges.right.addEventListener('click', () => nudge(0.005,0));
    nudges.up.addEventListener('click', () => nudge(0,0.005));
    nudges.down.addEventListener('click', () => nudge(0,-0.005));

    // allow user tap to start video if autoplay blocked
    document.body.addEventListener('click', () => { vid.play().catch(()=>{}); });

    // initial message
    msg.textContent = 'Enter printed width (cm) and click Apply. Then point camera at target.';
  })();
  </script>
</body>
</html>
