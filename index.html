<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0"/>
  <title>Sk marker</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <!-- AR.js via raw.githack (less likely to be blocked) -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    .hint { position: fixed; left: 8px; top: 8px; color: white; font-family: Arial, sans-serif; z-index: 9999; background: rgba(0,0,0,0.5); padding:6px 8px; border-radius:6px; }
    #manual-play { position: fixed; left:50%; top:50%; transform: translate(-50%,-50%); z-index:99999; padding:12px 18px; border-radius:8px; border:none; background:#fff; color:#000; font-weight:600; display:none; }
  </style>
</head>
<body>
  <div class="hint">Point your camera at the printed marker. Allow camera permission. (Use poster/print/second screen)</div>

  <!-- Video: muted so mobile allows autoplay. Put a poster image if you want a still while loading -->
  <video id="ar-video" playsinline webkit-playsinline muted preload="auto" loop crossorigin="anonymous" style="display:none;" poster="poster.jpg">
    <source src="video.mp4" type="video/mp4">
  </video>

  <button id="manual-play">Tap to start video</button>

  <a-scene embedded vr-mode-ui="enabled: false"
         renderer="antialias: true; logarithmicDepthBuffer: true;"
         arjs="sourceType: webcam; debugUIEnabled: false; maxDetectionRate: 30;">

  <!-- Use a high-quality local .patt or the default hiro for testing -->
  <a-marker type="pattern" url="./mytarget.patt" id="marker">
    <a-plane id="video-plane" position="0 0 0" rotation="-90 0 0" width="1" height="0.5625"
             material="shader: flat; src: #ar-video; transparent: true;"></a-plane>
  </a-marker>
  <a-entity camera></a-entity>
</a-scene>

<script>
  (function () {
    const video = document.getElementById('ar-video');
    const marker = document.getElementById('marker');

    // make sure video is ready for texture use
    video.muted = true;
    video.playsInline = true;
    video.setAttribute('playsinline','');
    video.load(); video.pause();

    // small debounce to avoid rapid play/pause flicker
    let foundTimer = null;
    let lostTimer = null;
    const FOUND_DELAY_MS = 120; // wait a little before starting
    const LOST_DELAY_MS = 180;  // wait before pausing (prevents flicker)

    function safePlay() {
      video.play().catch(()=>{/* manual fallback shown elsewhere */});
    }
    function safePause() {
      try { video.pause(); } catch(e) {}
    }

    marker.addEventListener('markerFound', () => {
      clearTimeout(lostTimer);
      foundTimer = setTimeout(() => {
        // double check object3D visibility
        const vis = marker.object3D && marker.object3D.visible;
        if (vis) safePlay();
      }, FOUND_DELAY_MS);
    });

    marker.addEventListener('markerLost', () => {
      clearTimeout(foundTimer);
      lostTimer = setTimeout(() => {
        safePause();
      }, LOST_DELAY_MS);
    });

    // optional: smooth plane transforms (reduces jitter visually)
    // Use small lerp smoothing of the plane position/rotation each tick
    const plane = document.getElementById('video-plane');
    let targetPos = new THREE.Vector3(), curPos = new THREE.Vector3();
    let targetRot = new THREE.Euler(), curRot = new THREE.Euler();
    const SMOOTH = 0.15; // increase for more smoothing (but increases latency)

    AFRAME.registerComponent('smooth-follow', {
      tick: function () {
        if (!marker.object3D) return;
        // get marker world position/rotation
        marker.object3D.getWorldPosition(targetPos);
        marker.object3D.getWorldQuaternion(new THREE.Quaternion()).toEuler(targetRot); // pseudo; convert quat to euler below if needed
        // lerp position
        curPos.lerp(targetPos, SMOOTH);
        plane.object3D.position.copy(curPos);
        // lerp rotation (optional: use slerp for quaternion)
        // plane.object3D.rotation.copy(curRot.lerp ? curRot.lerp(targetRot, SMOOTH) : targetRot);
      }
    });
    // attach smoothing to plane
    plane.setAttribute('smooth-follow','');

  })();
</script>

</body>
</html>
